Collection of design best practices. Always strive to apply them: if you want to avoid using them, you need to have a really, really good reason to.
1. Classes should be *immutable*.
2. Only a small handful of classes should have *dependencies* (imported classes/interfaces, object arguments to constructors or methods, global values, etc.). The vast majority of classes should have no dependency.
3. You should not use *setters* (immutability) nor *getters* (tell, don't ask), unless it's a simple value object with no behavior (in which case you cannot "tell" it anything).
4. You should use as few *private fields* as possible: this will lower the LCOM (Lack of Cohesion Of Methods) factor, reduce the number of responsibilities, and increase the purity of methods. In the ideal case, each method should deal with exactly one private field, which is also the only field encapsulated by the class. These are actually to be interpreted as "conceptual" fields: if I have a `Time` class, exposing methods like `getHour()`, `getMinute()` and `getSeconds()`, I can use either one private field `seconds`, or three fields `hour`, `minute`, `seconds`, but in both cases I'd be dealing with only one "conceptual" `time` field, which is also what this value object is representing; in other words, `hour`, `minute` and `seconds`, despite being physically separate fields, already represent a highly cohesive system. Regarding purity, in functional programming a pure function would be something like `add(1, 2)` which doesn't depend on any dependency except for the arguments passed; we can simulate this treating one argument as the "conceptual" field of our object, like with a `Number` class containing the `number` field, and the `add(Number)` method using it.
5. Avoid using *static methods*, avoid defining methods not depending on any private field. Rather, create a new class encapsulating one of the arguments.
6. Wait until the *latest possible moment* before doing a computation or acquiring a dependency. If needed, use memoization or proxies.
7. Avoid *mixing dependencies and required values* in the constructor. Dependencies are intended here as services that the object will use, while required values are values that are required to be known since the construction. To avoid mixing the two, you should consider that if your object is using services, it's not an entity or a value object (whose semantic is to model a specific information), and thus the required value it's taking will probably be consumed by some services anyway. Thus, instead of injecting the raw values, inject a new service that has the responsibility of consuming those values (that service will take just the required values in the constructor). For instance, instead of `new Router(new Parser(), routes)`, use `new Router(new Parser(), new Selector(routes))`.
8. Avoid *calling methods without using their return value*. This would mean using a method for its side-effect, and you should rather prefer pure functions. Isolate required side-effects into dedicated classes, or dedicated methods.