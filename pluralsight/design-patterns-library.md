Design patterns are very general, non generic, templates to how to solve common problems in software designs. They are not like software components or assemblys, because they are elements of reuse, and design patterns are not elements of reuse: they are meant to address how specific classes or class elements elated to each other to solve a very common problem type.

Design patterns are related to application and system design domains. There are patterns at both very high level, and low level. Design patterns are concerned with the interfaces of our classes, not with the details, like class names. Design patterns are not concerned with implementations of classes, they give only a starting point, because situations differ.

## The Adapter pattern
Consider a class that would be useful to your application, but which does not implement an interface you require; or, you are designing a class or a framework and you want to ensure it is usable by a wide variety of as-yet-unwritten classes and applications: in this case you would add support to adapter to other classes to you framework. Object adapters do not require multiple inheritance, as class adapters do.

The intent of the adapter pattern is to convert the interface of one class into another interface, its client expects. This allows classes to work together, that wouldn't otherwise. In this way we can future proof client implementations by having them depend on adapter interfaces, rather than concrete classes directly.

Consider using the adapter pattern whenever you want to use an existing class's functionality, but its interface is not the one that you require. Likewise if you want to create reusable code, but you don't want to bind it too tightly to a particular implementation, you should use some kind of adapter interface as what your code depends on, so that future clients could implement their own version of that adapter and still make use of your code. You'll also find the adapter pattern useful if there are several existing implementations of code that you want to be able to use and it's impractical to adapt each of their interfaces by subclassing every one. By implementing an adapter and writing an adapter for each of these subclasses, for instance if you have a data access class, one for SQL server, another for Oracle, another for DB2, you would be able to create a data adapter, and create just the adapter classes for each of those different implementations, rather than trying to change those implementations directly to expose the interface that you require.

The two basic players of the adapter pattern are the client and the adaptee. The client needs some of the logic provided by the adaptee, `adaptedOperation()`, but the client has been written in such a way that it can't directly call `adaptedOperation()`, because its interface is not the one the client expects: `operation()`. So we create an adapter interface, exposing an operation that has the interface the client expects, so `operation()`. Next, for each different implementation required, at a minimum one, a different concrete adapter is created, that takes that `operation()` and implements it such that that code calls `adaptedOperation()`. In this way the original client will now be able to use the original `adaptedOperation()`, while actually calling the `operation()` it knows about, on the adapter.

The way the adapter pattern is used is that client classes are written in such a way that they depend on an interface, rather than on a particular implementation. Then at least one concrete adapter class is created, which implements this interface, allowing the client to work with a particular class that it requires. Or, you may already have the client and the concrete adapter under your control, and you are just writing the adapter interface to decouple the client from the adapter interface: in this way we are future proofing the client, allowing for later changes to be implemented through its behaviour, by simply writing new adapters that work with new implementations of this code. This is a very effective way to achieve the Open/Closed principle.